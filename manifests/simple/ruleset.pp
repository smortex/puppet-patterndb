#
define patterndb::simple::ruleset (
  $pubdate,
  $patterns = [],
  $rules = [],
  $id = $name,
  $parser = 'default',
  $version        = 4,
  $description    = 'generated by puppet',
  $url            = undef,
  $order = '',
) {

  if ! defined(Class['Patterndb']) {
    include patterndb
  }

  $patterns_a = patterndb::string2array($patterns)
  $rules_a = patterndb::hash2array($rules)
  validate_string($order)
  validate_string($url)
  validate_string($parser)
  validate_string($description)
  validate_string($pubdate)
  if is_string($version) {
    # let's come back to this when puppet has proper types
    # validate_re($version, '^\d+$')
  } elsif is_integer($version) {
    # everything okay
  } else {
    fail('version must be integer(ish)')
  }
  validate_re($pubdate, '^\d+-\d+-\d+$')

  if ! defined(Patterndb::Parser[$parser]) {
    patterndb::parser { $parser:
      test_before_deploy => $::patterndb::test_before_deploy,
      syslogng_modules   => $::patterndb::syslogng_modules,
    }
  }

  $pdb_file = "${patterndb::pdb_dir}/${parser}/${order}${name}.pdb"

  concat { "patterndb_simple_ruleset-${title}":
    path   => $pdb_file,
    notify => Exec["patterndb::merge::${parser}"],
  }

  concat::fragment { "patterndb_simple_ruleset-${title}-header":
    target  => "patterndb_simple_ruleset-${title}",
    content => template('patterndb/ruleset-header.erb'),
    order   => '001'
  }
  concat::fragment { "patterndb_simple_ruleset-${title}-footer":
    target  => "patterndb_simple_ruleset-${title}",
    content => template('patterndb/ruleset-footer.erb'),
    order   => 'zzz'
  }

  if (! empty($rules)) { # monolithic ruleset definition
    # import embedded rules
    patterndb::patterndb_simple_rule ($name, $rules_a)
  }
}
